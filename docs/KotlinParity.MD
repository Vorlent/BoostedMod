It has come to my attention that an alien web forum has suggested
that that Java will soon reach feature parity with Jetbrains new
fancy programming language.

I am not in need of many complicated features. Here are my three
biggest gripes with Java.

1. Everything is mutable by default in a world where
most parameters, variables and fields are never being modified
2. Everything is nullable by default in a world where nullability is baggage 
and widely considered inappropriate even in Java
where Optional is supposed to take its place.
3. Getters and Setters, equals, hashcode clutter up the code for no reason. One might be tempted to get rid of setters,
which is indeed feasible. Using the IDE to autogenerate the code is unsatisfying since
the code isn't being regenerated by your build process. There is no source level lombok that simply marks
one part of your class as an autogenerated and autocollapsed section of code, so we never have to waste a single brain
cell on this topic ever again.

Okay. So after some research, SpotBugs appears to be capable of living up to the challenge.
Well, so much for Java catching up with Kotlin. It looks like Java is in need of crutches.
Nothing prevents Java from simply adopting a simple <Type>! syntax for non nullability and <Type>?
for explicit nullability. Compilers could then give you a warning for not using either syntax.
The problem would be solved once and for all, and it could have been solved in 2006 (JEP 323), before the vast majority
of modern Java code was written.

The same can be said of final which simply needs the opposite:
explicit mutability via @Mutable or a 'mutable' keyword with a configurable compiler warning
if you use the default. That's all it takes.

Since Java hasn't even taken a tiny step toward parity with Kotlin in the most basic aspects,
I would say that Java is at least one or two decades behind Kotlin once you consider that more advanced features
are missing from Java.

So we are now stuck with using static analysis tools like SpotBugs.

So, can we even achieve Kotlin parity by static analysis?

We have to take a look at what we are trying to achieve first.

The key aspect is that we cannot trust the defaults. The programmer is supposed to explicitly
declare that he wants mutability or immutability, nullability or non-nullability.
An asymmetric syntax where one requires no effort and one requires some effort always results 
in the path of the least effort being taken even if that path is suboptimal in the long run.

It is not sufficient to just leave a mutable field without a @Mutable or a nullable field without a @Nullable annotation,
because how is the static analysis tool supposed to differentiate between accidential
mutability and intentional mutability? It can't and therefore we need both.

We have established the need for the following annotations @Mutable, @Nullable, @NotNull,
the keyword final and the class Optional.

The only logical options are:

`@NotNull final` which represents the bread and butter type of variable. This is the default in Kotlin, and therefore
it should be used everywhere in Java as well.
`@NotNull final Optional<T>` represents the most common case where the value may not be present.
We still need @NotNull to prevent the fringe case of Optional<T> being null itself. Equivalent to `val t : Type? in Kotlin`.
`@Nullable final` is needed only for very few cases where performance or interoperability matter. Parity with Kotlin is not relevant.

`@NotNull @Mutable` represents the standard mutable variable which should be relatively uncommon in your code.
(why are parameters not final by default? It defies common sense.)
`@NotNull @Mutable Optional<T>` represents mutable variables where the object may not be present. `var t : Type? in Kotlin`
`@Nullable @Mutable` is needed only for very few cases where performance or interoperability matter. Parity with Kotlin is not relevant.

It doesn't look too bad, doesn't it? We just need to figure out which annotations SpotBugs supports that
work equivalently to their Kotlin counterpart. It doesn't sound like a hard problem, right?
We just throw a bunch of annotations on our packages and the tool will do our work? Is Kotlin obsolete at last?

Here is an interesting starting point:

https://stackoverflow.com/questions/13310994/set-findbugs-notnull-as-default-for-all-classes-under-a-package

javax.annotation.ParametersAreNonnullByDefault;

Does what it says on the tin. It means your normal variables are NonnullByDefault which mirrors Kotlin.
Explicit @Nullable annotations are necessary which mirrors the Type? syntax of Kotlin although with some verbosity.

However, this annotation only affects parameters.

Since we are modding Minecraft we also have import net.minecraft.util.annotation.FieldsAreNonnullByDefault
and import net.minecraft.util.annotation.MethodsReturnNonnullByDefault.

We are still missing local variables.

Ok, so... I tried and then gave up. Java is still stuck in the 90s.